# CarND-Path-Planning-Project

## Path Generation

The Path Generation has three sections, encoded in the class `NextValsCalculator`

1. Calculates a strategy considering the traffic and the current car's location
2. Constructs a spline line considering the car's lane and map waypoints
3. Generates a future path array of points considering the strategy and the spline generated previously

## Strategy calculation

The strategy that I have encoded has four different states:
1. Stay in lane at maximum speed
2. Follow the car in front
3. Move to the lane on the left
4. Move to the lane on the right


```
bool stay_in_lane_at_maximum_speed = true;
bool follow_car_in_front = false;
bool safe_to_move_left_lane = false;
bool safe_to_move_right_lane = false;
```

In order to find out which strategy to apply we have to loop through all the cars' data provided by the `sensor_fusion` input and we will extract the speed, lane and position of all the other cars.

With this information we will find out if the car is in the same lane, on the left lane or on the right lane.

Once we know where are the cars we need to filter all the cars by its distance as we will only care about the cars that are around us in order to select the correct state.

```
if (same_lane_car(other_car_d, car_lane)) {
    if (same_lane_car_is_too_close(other_car_s, car_s)) {
        stay_in_lane_at_maximum_speed = false;
        follow_car_in_front = true;

        target_car_in_front_speed = other_car_speed;
        target_car_in_front_position = other_car_s;
    } 
} else if (left_lane_car(other_car_d, car_lane)) {
    if (different_lane_car_is_too_close(other_car_s, car_s)) {
        safe_to_move_left_lane = false;
        target_car_in_front_speed = other_car_speed;
    }
} else if (right_lane_car(other_car_d, car_lane)) {
    if (different_lane_car_is_too_close(other_car_s, car_s)) {
        safe_to_move_right_lane = false;
        target_car_in_front_speed = other_car_speed;
    }
}
```

### Checks for other cars in a different lane

The case `different_lane_car_is_too_close` is interesting because we will do two different checks, one check for the car that's in front and another check for the car that's behind. Both distances have been considered to be in diagonal and not straight as the car in front. The distance for the check for the car on the back is 10, and the distance for the check for the car on the front is 30, being 20 the distance for the check for the car that's in the same lane.

If we decide a lane change we want ensure that the if there is a car on front, that car is further away that the car that we have in front in the same lane, otherwise it wouldn't make sense to do a lane change.

We also need to check for cars on the back as we might collilde with them if we do not leave a safety distance. This distance is not obvious to find as we do not want to stay in our current lane if the car behind is far away, but also we do not want to collide with it if the car behind is accelerating and we start the maniouver.

### Actions on the strategy selected

Once the checks are done, we will have a list of all possible statuses that we are allowed to take, as an example we could have `stay_in_lane_at_maximum_speed` and `safe_to_move_left_lane` active as valid statuses, then we need to choose one and actuate on it.

*Stay in the lane at maximum speed* will increase the velocity at maximum acceleration

*Is safe to change lane and we can change lane* then we will change lane and we will reduce the velocity while its faster than the car on that other lane

*Follow the car in front* will aim to keep a safety distance that's between 20 (`safety_distance_front_car`) and 3 (`safety_distance_following_car`). Instead of applying maximum break down force, I have implemented a linear approach by with the further we are the less force we will apply (implemented as the less speed decrement)

```
const double slow_down_parameter = maximum_allowed_speed_increment / 
    (safety_distance_front_car - safety_distance_following_car);

double car_separation = target_car_in_front_position - car_s;
double car_speed_decrement = slow_down(car_separation);
ref_vel -= car_speed_decrement;

double slow_down(double car_separation) {
    double distance_to_safety = car_separation - safety_distance_following_car;
    if (distance_to_safety < 0) {
        // emergency break
        return maximum_allowed_speed_increment;
    } else {
        return maximum_allowed_speed_increment - (distance_to_safety * slow_down_parameter);
    }
}
```

An improvement on this approach would have been the implementation of a more complex break down calculation with a PID.

The end of the strategy calculation will prodice a reference velocity `ref_vel` and a target lane `car_lane`

## Spline construction

The car will follow a path generated by a smooth spline, this spline will be created from the current's car position, and with its yaw we will generate additional points that follows the car direction. Once we have more that two points we will use two previous points and its `atac`.

```
if (prev_size < 2) {
    double prev_car_x = car_x - cos(car_yaw);
    double prev_car_y = car_y - sin(car_yaw);

    anchor_points_x.push_back(prev_car_x);
    anchor_points_x.push_back(car_x);

    anchor_points_y.push_back(prev_car_y);
    anchor_points_y.push_back(car_y);
} else {
    ref_x = previous_path_x[prev_size - 1];
    ref_y = previous_path_y[prev_size - 1];

    double ref_x_prev = previous_path_x[prev_size - 2];
    double ref_y_prev = previous_path_y[prev_size - 2];
    ref_yaw = atan2(ref_y - ref_y_prev, ref_x - ref_x_prev);

    anchor_points_x.push_back(ref_x_prev);
    anchor_points_x.push_back(ref_x);

    anchor_points_y.push_back(ref_y_prev);
    anchor_points_y.push_back(ref_y);
}
```

Once we have all the straight points, we will generate the turns to the selected lane `car_lane` generating points at a distance of 30, 60 and 90 from the current's car position. This will generate a smooth spline preventing the car from turning too violently.

The last thing that we will do is to turn all the generated points so that they at aligned to a `yaw`' car of zero degrees; this will help with the generation of the spline mathematically speaking.

```
for (int i = 0; i < anchor_points_x.size(); i++) {
    double shift_x = anchor_points_x[i] - ref_x;
    double shift_y = anchor_points_y[i] - ref_y;

    anchor_points_x[i] = shift_x * cos(0 - ref_yaw) - shift_y * sin(0 - ref_yaw);
    anchor_points_y[i] = shift_x * sin(0 - ref_yaw) + shift_y * cos(0 - ref_yaw);
}
```

## Future path generation

Once we have a spline to follow and a reference velocity `ref_vel` we will then generate the `x` and `y` coordinates of this future path.

As the car will be positioned at those particular coordinates, the closer they are the slower the car will go, the further the fastest the car will go.

We already have a reference velocity to achieve and a spline to follow, we will then calculate how many points we need to generate and the distance between those points in order to achieve the desired velocity.

We will use the following formula:
`target distance = number of point * 0.02s * reference velocity`

Where the target distance will be the car in front of our current car and the reference velocity will be the `ref_vel` calculated in our strategy.

Once we have the distance between our points we will generate up to 50 points forwards using the spline as our projection function.

As the split was generated turning the points to be aligned to a `yaw` of zero degrees, we will reverse that turn in order to generate the map coordinates.

```
double target_x = target_car_in_front_position;
double target_y = spline(target_x);
double target_dist = sqrt((target_x * target_x) + (target_y * target_y));    
double N = target_dist / (0.02 * ref_vel / 2.24); // 2.24 MPH -> meters per second
double distance_between_points = target_x / N;

double x_add_on = 0;

for (int i = 1; i <= 50 - previous_path_x.size(); i++) {
    double x_point = x_add_on + distance_between_points;
    double y_point = spline(x_point);

    x_add_on = x_point;

    double x_ref = x_point;
    double y_ref = y_point;

    // WE ROTATE BACK TO NORMAL
    x_point = x_ref * cos(ref_yaw) - y_ref * sin(ref_yaw);
    y_point = x_ref * sin(ref_yaw) + y_ref * cos(ref_yaw);

    x_point += ref_x;
    y_point += ref_y;

    future_path_x.push_back(x_point);
    future_path_y.push_back(y_point);
}

NextVals nextVals;
nextVals.next_x_vals_ = future_path_x;
nextVals.next_y_vals_ = future_path_y;
```

## Conclusions

Path Planning can easely increase in complexity the more cases we want to consider and it would require a deeper analysis on emergency situations, high traffic scenarios and customer comfort.

We haven't included a `prepare for lane change` state in our strategy calculations as the current implementation solves the majority of the lane changes successfuly, but it would be an improvement to implement a more solid approach to lane changes.

When following a car that's in front of us, we could improve the algorithm so that instead of slowing down and then accelerating when the car enters/exist the security distance, it could minimise the oscilations following closely to the car that's in front of us. I have indeed experimented with different approaches, including a slow down mechanism that synchronised with speed of the car in front of us; even though it worked for a while, the sensor fusion was giving me inaccurate readings for the other's car speed leaving this method not reliable.

Changing lanes had a preference to the left lane. We could improve the checks and search for the closets car in every lane. Then choose the lane with the furthest car available.

Speed control and turn control could be improved by adding PID or MPC to the code, using the spline as a reference instead of a hard coded path.

[Video code running](https://youtu.be/nYJweocOgsw)